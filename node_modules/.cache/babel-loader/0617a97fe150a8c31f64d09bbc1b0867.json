{"ast":null,"code":"/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Reads in-band caption information from a video elementary\n * stream. Captions must follow the CEA-708 standard for injection\n * into an MPEG-2 transport streams.\n * @see https://en.wikipedia.org/wiki/CEA-708\n * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n */\n'use strict'; // Supplemental enhancement information (SEI) NAL units have a\n// payload type field to indicate how they are to be\n// interpreted. CEAS-708 caption content is always transmitted with\n// payload type 0x04.\n\nvar USER_DATA_REGISTERED_ITU_T_T35 = 4,\n    RBSP_TRAILING_BITS = 128;\n/**\n  * Parse a supplemental enhancement information (SEI) NAL unit.\n  * Stops parsing once a message of type ITU T T35 has been found.\n  *\n  * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n  * @return {object} the parsed SEI payload\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\n  */\n\nvar parseSei = function parseSei(bytes) {\n  var i = 0,\n      result = {\n    payloadType: -1,\n    payloadSize: 0\n  },\n      payloadType = 0,\n      payloadSize = 0; // go through the sei_rbsp parsing each each individual sei_message\n\n  while (i < bytes.byteLength) {\n    // stop once we have hit the end of the sei_rbsp\n    if (bytes[i] === RBSP_TRAILING_BITS) {\n      break;\n    } // Parse payload type\n\n\n    while (bytes[i] === 0xFF) {\n      payloadType += 255;\n      i++;\n    }\n\n    payloadType += bytes[i++]; // Parse payload size\n\n    while (bytes[i] === 0xFF) {\n      payloadSize += 255;\n      i++;\n    }\n\n    payloadSize += bytes[i++]; // this sei_message is a 608/708 caption so save it and break\n    // there can only ever be one caption message in a frame's sei\n\n    if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n      result.payloadType = payloadType;\n      result.payloadSize = payloadSize;\n      result.payload = bytes.subarray(i, i + payloadSize);\n      break;\n    } // skip the payload and parse the next message\n\n\n    i += payloadSize;\n    payloadType = 0;\n    payloadSize = 0;\n  }\n\n  return result;\n}; // see ANSI/SCTE 128-1 (2013), section 8.1\n\n\nvar parseUserData = function parseUserData(sei) {\n  // itu_t_t35_contry_code must be 181 (United States) for\n  // captions\n  if (sei.payload[0] !== 181) {\n    return null;\n  } // itu_t_t35_provider_code should be 49 (ATSC) for captions\n\n\n  if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {\n    return null;\n  } // the user_identifier should be \"GA94\" to indicate ATSC1 data\n\n\n  if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== 'GA94') {\n    return null;\n  } // finally, user_data_type_code should be 0x03 for caption data\n\n\n  if (sei.payload[7] !== 0x03) {\n    return null;\n  } // return the user_data_type_structure and strip the trailing\n  // marker bits\n\n\n  return sei.payload.subarray(8, sei.payload.length - 1);\n}; // see CEA-708-D, section 4.4\n\n\nvar parseCaptionPackets = function parseCaptionPackets(pts, userData) {\n  var results = [],\n      i,\n      count,\n      offset,\n      data; // if this is just filler, return immediately\n\n  if (!(userData[0] & 0x40)) {\n    return results;\n  } // parse out the cc_data_1 and cc_data_2 fields\n\n\n  count = userData[0] & 0x1f;\n\n  for (i = 0; i < count; i++) {\n    offset = i * 3;\n    data = {\n      type: userData[offset + 2] & 0x03,\n      pts: pts\n    }; // capture cc data when cc_valid is 1\n\n    if (userData[offset + 2] & 0x04) {\n      data.ccData = userData[offset + 3] << 8 | userData[offset + 4];\n      results.push(data);\n    }\n  }\n\n  return results;\n};\n\nvar discardEmulationPreventionBytes = function discardEmulationPreventionBytes(data) {\n  var length = data.byteLength,\n      emulationPreventionBytesPositions = [],\n      i = 1,\n      newLength,\n      newData; // Find all `Emulation Prevention Bytes`\n\n  while (i < length - 2) {\n    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n      emulationPreventionBytesPositions.push(i + 2);\n      i += 2;\n    } else {\n      i++;\n    }\n  } // If no Emulation Prevention Bytes were found just return the original\n  // array\n\n\n  if (emulationPreventionBytesPositions.length === 0) {\n    return data;\n  } // Create a new array to hold the NAL unit data\n\n\n  newLength = length - emulationPreventionBytesPositions.length;\n  newData = new Uint8Array(newLength);\n  var sourceIndex = 0;\n\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === emulationPreventionBytesPositions[0]) {\n      // Skip this byte\n      sourceIndex++; // Remove this position index\n\n      emulationPreventionBytesPositions.shift();\n    }\n\n    newData[i] = data[sourceIndex];\n  }\n\n  return newData;\n}; // exports\n\n\nmodule.exports = {\n  parseSei: parseSei,\n  parseUserData: parseUserData,\n  parseCaptionPackets: parseCaptionPackets,\n  discardEmulationPreventionBytes: discardEmulationPreventionBytes,\n  USER_DATA_REGISTERED_ITU_T_T35: USER_DATA_REGISTERED_ITU_T_T35\n};","map":{"version":3,"sources":["/Users/soier/Code/studio_v_shawn/studio_v2/node_modules/mux.js/lib/tools/caption-packet-parser.js"],"names":["USER_DATA_REGISTERED_ITU_T_T35","RBSP_TRAILING_BITS","parseSei","bytes","i","result","payloadType","payloadSize","byteLength","payload","subarray","parseUserData","sei","String","fromCharCode","length","parseCaptionPackets","pts","userData","results","count","offset","data","type","ccData","push","discardEmulationPreventionBytes","emulationPreventionBytesPositions","newLength","newData","Uint8Array","sourceIndex","shift","module","exports"],"mappings":"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","sourcesContent":["/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Reads in-band caption information from a video elementary\n * stream. Captions must follow the CEA-708 standard for injection\n * into an MPEG-2 transport streams.\n * @see https://en.wikipedia.org/wiki/CEA-708\n * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n */\n\n'use strict';\n\n// Supplemental enhancement information (SEI) NAL units have a\n// payload type field to indicate how they are to be\n// interpreted. CEAS-708 caption content is always transmitted with\n// payload type 0x04.\nvar USER_DATA_REGISTERED_ITU_T_T35 = 4,\n    RBSP_TRAILING_BITS = 128;\n\n/**\n  * Parse a supplemental enhancement information (SEI) NAL unit.\n  * Stops parsing once a message of type ITU T T35 has been found.\n  *\n  * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n  * @return {object} the parsed SEI payload\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\n  */\nvar parseSei = function(bytes) {\n  var\n    i = 0,\n    result = {\n      payloadType: -1,\n      payloadSize: 0\n    },\n    payloadType = 0,\n    payloadSize = 0;\n\n  // go through the sei_rbsp parsing each each individual sei_message\n  while (i < bytes.byteLength) {\n    // stop once we have hit the end of the sei_rbsp\n    if (bytes[i] === RBSP_TRAILING_BITS) {\n      break;\n    }\n\n    // Parse payload type\n    while (bytes[i] === 0xFF) {\n      payloadType += 255;\n      i++;\n    }\n    payloadType += bytes[i++];\n\n    // Parse payload size\n    while (bytes[i] === 0xFF) {\n      payloadSize += 255;\n      i++;\n    }\n    payloadSize += bytes[i++];\n\n    // this sei_message is a 608/708 caption so save it and break\n    // there can only ever be one caption message in a frame's sei\n    if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n      result.payloadType = payloadType;\n      result.payloadSize = payloadSize;\n      result.payload = bytes.subarray(i, i + payloadSize);\n      break;\n    }\n\n    // skip the payload and parse the next message\n    i += payloadSize;\n    payloadType = 0;\n    payloadSize = 0;\n  }\n\n  return result;\n};\n\n// see ANSI/SCTE 128-1 (2013), section 8.1\nvar parseUserData = function(sei) {\n  // itu_t_t35_contry_code must be 181 (United States) for\n  // captions\n  if (sei.payload[0] !== 181) {\n    return null;\n  }\n\n  // itu_t_t35_provider_code should be 49 (ATSC) for captions\n  if (((sei.payload[1] << 8) | sei.payload[2]) !== 49) {\n    return null;\n  }\n\n  // the user_identifier should be \"GA94\" to indicate ATSC1 data\n  if (String.fromCharCode(sei.payload[3],\n                          sei.payload[4],\n                          sei.payload[5],\n                          sei.payload[6]) !== 'GA94') {\n    return null;\n  }\n\n  // finally, user_data_type_code should be 0x03 for caption data\n  if (sei.payload[7] !== 0x03) {\n    return null;\n  }\n\n  // return the user_data_type_structure and strip the trailing\n  // marker bits\n  return sei.payload.subarray(8, sei.payload.length - 1);\n};\n\n// see CEA-708-D, section 4.4\nvar parseCaptionPackets = function(pts, userData) {\n  var results = [], i, count, offset, data;\n\n  // if this is just filler, return immediately\n  if (!(userData[0] & 0x40)) {\n    return results;\n  }\n\n  // parse out the cc_data_1 and cc_data_2 fields\n  count = userData[0] & 0x1f;\n  for (i = 0; i < count; i++) {\n    offset = i * 3;\n    data = {\n      type: userData[offset + 2] & 0x03,\n      pts: pts\n    };\n\n    // capture cc data when cc_valid is 1\n    if (userData[offset + 2] & 0x04) {\n      data.ccData = (userData[offset + 3] << 8) | userData[offset + 4];\n      results.push(data);\n    }\n  }\n  return results;\n};\n\nvar discardEmulationPreventionBytes = function(data) {\n    var\n      length = data.byteLength,\n      emulationPreventionBytesPositions = [],\n      i = 1,\n      newLength, newData;\n\n    // Find all `Emulation Prevention Bytes`\n    while (i < length - 2) {\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2);\n        i += 2;\n      } else {\n        i++;\n      }\n    }\n\n    // If no Emulation Prevention Bytes were found just return the original\n    // array\n    if (emulationPreventionBytesPositions.length === 0) {\n      return data;\n    }\n\n    // Create a new array to hold the NAL unit data\n    newLength = length - emulationPreventionBytesPositions.length;\n    newData = new Uint8Array(newLength);\n    var sourceIndex = 0;\n\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        // Skip this byte\n        sourceIndex++;\n        // Remove this position index\n        emulationPreventionBytesPositions.shift();\n      }\n      newData[i] = data[sourceIndex];\n    }\n\n    return newData;\n};\n\n// exports\nmodule.exports = {\n  parseSei: parseSei,\n  parseUserData: parseUserData,\n  parseCaptionPackets: parseCaptionPackets,\n  discardEmulationPreventionBytes: discardEmulationPreventionBytes,\n  USER_DATA_REGISTERED_ITU_T_T35: USER_DATA_REGISTERED_ITU_T_T35\n};\n"]},"metadata":{},"sourceType":"script"}