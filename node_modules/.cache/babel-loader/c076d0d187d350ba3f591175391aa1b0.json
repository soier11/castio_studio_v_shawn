{"ast":null,"code":"/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Reads in-band CEA-708 captions out of FMP4 segments.\n * @see https://en.wikipedia.org/wiki/CEA-708\n */\n'use strict';\n\nvar discardEmulationPreventionBytes = require('../tools/caption-packet-parser').discardEmulationPreventionBytes;\n\nvar CaptionStream = require('../m2ts/caption-stream').CaptionStream;\n\nvar probe = require('./probe');\n\nvar inspect = require('../tools/mp4-inspector');\n/**\n  * Maps an offset in the mdat to a sample based on the the size of the samples.\n  * Assumes that `parseSamples` has been called first.\n  *\n  * @param {Number} offset - The offset into the mdat\n  * @param {Object[]} samples - An array of samples, parsed using `parseSamples`\n  * @return {?Object} The matching sample, or null if no match was found.\n  *\n  * @see ISO-BMFF-12/2015, Section 8.8.8\n **/\n\n\nvar mapToSample = function mapToSample(offset, samples) {\n  var approximateOffset = offset;\n\n  for (var i = 0; i < samples.length; i++) {\n    var sample = samples[i];\n\n    if (approximateOffset < sample.size) {\n      return sample;\n    }\n\n    approximateOffset -= sample.size;\n  }\n\n  return null;\n};\n/**\n  * Finds SEI nal units contained in a Media Data Box.\n  * Assumes that `parseSamples` has been called first.\n  *\n  * @param {Uint8Array} avcStream - The bytes of the mdat\n  * @param {Object[]} samples - The samples parsed out by `parseSamples`\n  * @param {Number} trackId - The trackId of this video track\n  * @return {Object[]} seiNals - the parsed SEI NALUs found.\n  *   The contents of the seiNal should match what is expected by\n  *   CaptionStream.push (nalUnitType, size, data, escapedRBSP, pts, dts)\n  *\n  * @see ISO-BMFF-12/2015, Section 8.1.1\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\n **/\n\n\nvar findSeiNals = function findSeiNals(avcStream, samples, trackId) {\n  var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n      result = [],\n      seiNal,\n      i,\n      length,\n      lastMatchedSample;\n\n  for (i = 0; i + 4 < avcStream.length; i += length) {\n    length = avcView.getUint32(i);\n    i += 4; // Bail if this doesn't appear to be an H264 stream\n\n    if (length <= 0) {\n      continue;\n    }\n\n    switch (avcStream[i] & 0x1F) {\n      case 0x06:\n        var data = avcStream.subarray(i + 1, i + 1 + length);\n        var matchingSample = mapToSample(i, samples);\n        seiNal = {\n          nalUnitType: 'sei_rbsp',\n          size: length,\n          data: data,\n          escapedRBSP: discardEmulationPreventionBytes(data),\n          trackId: trackId\n        };\n\n        if (matchingSample) {\n          seiNal.pts = matchingSample.pts;\n          seiNal.dts = matchingSample.dts;\n          lastMatchedSample = matchingSample;\n        } else {\n          // If a matching sample cannot be found, use the last\n          // sample's values as they should be as close as possible\n          seiNal.pts = lastMatchedSample.pts;\n          seiNal.dts = lastMatchedSample.dts;\n        }\n\n        result.push(seiNal);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  return result;\n};\n/**\n  * Parses sample information out of Track Run Boxes and calculates\n  * the absolute presentation and decode timestamps of each sample.\n  *\n  * @param {Array<Uint8Array>} truns - The Trun Run boxes to be parsed\n  * @param {Number} baseMediaDecodeTime - base media decode time from tfdt\n      @see ISO-BMFF-12/2015, Section 8.8.12\n  * @param {Object} tfhd - The parsed Track Fragment Header\n  *   @see inspect.parseTfhd\n  * @return {Object[]} the parsed samples\n  *\n  * @see ISO-BMFF-12/2015, Section 8.8.8\n **/\n\n\nvar parseSamples = function parseSamples(truns, baseMediaDecodeTime, tfhd) {\n  var currentDts = baseMediaDecodeTime;\n  var defaultSampleDuration = tfhd.defaultSampleDuration || 0;\n  var defaultSampleSize = tfhd.defaultSampleSize || 0;\n  var trackId = tfhd.trackId;\n  var allSamples = [];\n  truns.forEach(function (trun) {\n    // Note: We currently do not parse the sample table as well\n    // as the trun. It's possible some sources will require this.\n    // moov > trak > mdia > minf > stbl\n    var trackRun = inspect.parseTrun(trun);\n    var samples = trackRun.samples;\n    samples.forEach(function (sample) {\n      if (sample.duration === undefined) {\n        sample.duration = defaultSampleDuration;\n      }\n\n      if (sample.size === undefined) {\n        sample.size = defaultSampleSize;\n      }\n\n      sample.trackId = trackId;\n      sample.dts = currentDts;\n\n      if (sample.compositionTimeOffset === undefined) {\n        sample.compositionTimeOffset = 0;\n      }\n\n      sample.pts = currentDts + sample.compositionTimeOffset;\n      currentDts += sample.duration;\n    });\n    allSamples = allSamples.concat(samples);\n  });\n  return allSamples;\n};\n/**\n  * Parses out caption nals from an FMP4 segment's video tracks.\n  *\n  * @param {Uint8Array} segment - The bytes of a single segment\n  * @param {Number} videoTrackId - The trackId of a video track in the segment\n  * @return {Object.<Number, Object[]>} A mapping of video trackId to\n  *   a list of seiNals found in that track\n **/\n\n\nvar parseCaptionNals = function parseCaptionNals(segment, videoTrackId) {\n  // To get the samples\n  var trafs = probe.findBox(segment, ['moof', 'traf']); // To get SEI NAL units\n\n  var mdats = probe.findBox(segment, ['mdat']);\n  var captionNals = {};\n  var mdatTrafPairs = []; // Pair up each traf with a mdat as moofs and mdats are in pairs\n\n  mdats.forEach(function (mdat, index) {\n    var matchingTraf = trafs[index];\n    mdatTrafPairs.push({\n      mdat: mdat,\n      traf: matchingTraf\n    });\n  });\n  mdatTrafPairs.forEach(function (pair) {\n    var mdat = pair.mdat;\n    var traf = pair.traf;\n    var tfhd = probe.findBox(traf, ['tfhd']); // Exactly 1 tfhd per traf\n\n    var headerInfo = inspect.parseTfhd(tfhd[0]);\n    var trackId = headerInfo.trackId;\n    var tfdt = probe.findBox(traf, ['tfdt']); // Either 0 or 1 tfdt per traf\n\n    var baseMediaDecodeTime = tfdt.length > 0 ? inspect.parseTfdt(tfdt[0]).baseMediaDecodeTime : 0;\n    var truns = probe.findBox(traf, ['trun']);\n    var samples;\n    var seiNals; // Only parse video data for the chosen video track\n\n    if (videoTrackId === trackId && truns.length > 0) {\n      samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);\n      seiNals = findSeiNals(mdat, samples, trackId);\n\n      if (!captionNals[trackId]) {\n        captionNals[trackId] = [];\n      }\n\n      captionNals[trackId] = captionNals[trackId].concat(seiNals);\n    }\n  });\n  return captionNals;\n};\n/**\n  * Parses out inband captions from an MP4 container and returns\n  * caption objects that can be used by WebVTT and the TextTrack API.\n  * @see https://developer.mozilla.org/en-US/docs/Web/API/VTTCue\n  * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack\n  * Assumes that `probe.getVideoTrackIds` and `probe.timescale` have been called first\n  *\n  * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n  * @param {Number} trackId - The id of the video track to parse\n  * @param {Number} timescale - The timescale for the video track from the init segment\n  *\n  * @return {?Object[]} parsedCaptions - A list of captions or null if no video tracks\n  * @return {Number} parsedCaptions[].startTime - The time to show the caption in seconds\n  * @return {Number} parsedCaptions[].endTime - The time to stop showing the caption in seconds\n  * @return {String} parsedCaptions[].text - The visible content of the caption\n **/\n\n\nvar parseEmbeddedCaptions = function parseEmbeddedCaptions(segment, trackId, timescale) {\n  var seiNals; // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n\n  if (trackId === null) {\n    return null;\n  }\n\n  seiNals = parseCaptionNals(segment, trackId);\n  return {\n    seiNals: seiNals[trackId],\n    timescale: timescale\n  };\n};\n/**\n  * Converts SEI NALUs into captions that can be used by video.js\n **/\n\n\nvar CaptionParser = function CaptionParser() {\n  var isInitialized = false;\n  var captionStream; // Stores segments seen before trackId and timescale are set\n\n  var segmentCache; // Stores video track ID of the track being parsed\n\n  var trackId; // Stores the timescale of the track being parsed\n\n  var timescale; // Stores captions parsed so far\n\n  var parsedCaptions; // Stores whether we are receiving partial data or not\n\n  var parsingPartial;\n  /**\n    * A method to indicate whether a CaptionParser has been initalized\n    * @returns {Boolean}\n   **/\n\n  this.isInitialized = function () {\n    return isInitialized;\n  };\n  /**\n    * Initializes the underlying CaptionStream, SEI NAL parsing\n    * and management, and caption collection\n   **/\n\n\n  this.init = function (options) {\n    captionStream = new CaptionStream();\n    isInitialized = true;\n    parsingPartial = options ? options.isPartial : false; // Collect dispatched captions\n\n    captionStream.on('data', function (event) {\n      // Convert to seconds in the source's timescale\n      event.startTime = event.startPts / timescale;\n      event.endTime = event.endPts / timescale;\n      parsedCaptions.captions.push(event);\n      parsedCaptions.captionStreams[event.stream] = true;\n    });\n  };\n  /**\n    * Determines if a new video track will be selected\n    * or if the timescale changed\n    * @return {Boolean}\n   **/\n\n\n  this.isNewInit = function (videoTrackIds, timescales) {\n    if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === 'object' && Object.keys(timescales).length === 0) {\n      return false;\n    }\n\n    return trackId !== videoTrackIds[0] || timescale !== timescales[trackId];\n  };\n  /**\n    * Parses out SEI captions and interacts with underlying\n    * CaptionStream to return dispatched captions\n    *\n    * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n    * @param {Number[]} videoTrackIds - A list of video tracks found in the init segment\n    * @param {Object.<Number, Number>} timescales - The timescales found in the init segment\n    * @see parseEmbeddedCaptions\n    * @see m2ts/caption-stream.js\n   **/\n\n\n  this.parse = function (segment, videoTrackIds, timescales) {\n    var parsedData;\n\n    if (!this.isInitialized()) {\n      return null; // This is not likely to be a video segment\n    } else if (!videoTrackIds || !timescales) {\n      return null;\n    } else if (this.isNewInit(videoTrackIds, timescales)) {\n      // Use the first video track only as there is no\n      // mechanism to switch to other video tracks\n      trackId = videoTrackIds[0];\n      timescale = timescales[trackId]; // If an init segment has not been seen yet, hold onto segment\n      // data until we have one.\n      // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n    } else if (trackId === null || !timescale) {\n      segmentCache.push(segment);\n      return null;\n    } // Now that a timescale and trackId is set, parse cached segments\n\n\n    while (segmentCache.length > 0) {\n      var cachedSegment = segmentCache.shift();\n      this.parse(cachedSegment, videoTrackIds, timescales);\n    }\n\n    parsedData = parseEmbeddedCaptions(segment, trackId, timescale);\n\n    if (parsedData === null || !parsedData.seiNals) {\n      return null;\n    }\n\n    this.pushNals(parsedData.seiNals); // Force the parsed captions to be dispatched\n\n    this.flushStream();\n    return parsedCaptions;\n  };\n  /**\n    * Pushes SEI NALUs onto CaptionStream\n    * @param {Object[]} nals - A list of SEI nals parsed using `parseCaptionNals`\n    * Assumes that `parseCaptionNals` has been called first\n    * @see m2ts/caption-stream.js\n    **/\n\n\n  this.pushNals = function (nals) {\n    if (!this.isInitialized() || !nals || nals.length === 0) {\n      return null;\n    }\n\n    nals.forEach(function (nal) {\n      captionStream.push(nal);\n    });\n  };\n  /**\n    * Flushes underlying CaptionStream to dispatch processed, displayable captions\n    * @see m2ts/caption-stream.js\n   **/\n\n\n  this.flushStream = function () {\n    if (!this.isInitialized()) {\n      return null;\n    }\n\n    if (!parsingPartial) {\n      captionStream.flush();\n    } else {\n      captionStream.partialFlush();\n    }\n  };\n  /**\n    * Reset caption buckets for new data\n   **/\n\n\n  this.clearParsedCaptions = function () {\n    parsedCaptions.captions = [];\n    parsedCaptions.captionStreams = {};\n  };\n  /**\n    * Resets underlying CaptionStream\n    * @see m2ts/caption-stream.js\n   **/\n\n\n  this.resetCaptionStream = function () {\n    if (!this.isInitialized()) {\n      return null;\n    }\n\n    captionStream.reset();\n  };\n  /**\n    * Convenience method to clear all captions flushed from the\n    * CaptionStream and still being parsed\n    * @see m2ts/caption-stream.js\n   **/\n\n\n  this.clearAllCaptions = function () {\n    this.clearParsedCaptions();\n    this.resetCaptionStream();\n  };\n  /**\n    * Reset caption parser\n   **/\n\n\n  this.reset = function () {\n    segmentCache = [];\n    trackId = null;\n    timescale = null;\n\n    if (!parsedCaptions) {\n      parsedCaptions = {\n        captions: [],\n        // CC1, CC2, CC3, CC4\n        captionStreams: {}\n      };\n    } else {\n      this.clearParsedCaptions();\n    }\n\n    this.resetCaptionStream();\n  };\n\n  this.reset();\n};\n\nmodule.exports = CaptionParser;","map":{"version":3,"sources":["/Users/soier/Code/santa/studio_v2/node_modules/mux.js/lib/mp4/caption-parser.js"],"names":["discardEmulationPreventionBytes","require","CaptionStream","probe","inspect","mapToSample","offset","samples","approximateOffset","i","length","sample","size","findSeiNals","avcStream","trackId","avcView","DataView","buffer","byteOffset","byteLength","result","seiNal","lastMatchedSample","getUint32","data","subarray","matchingSample","nalUnitType","escapedRBSP","pts","dts","push","parseSamples","truns","baseMediaDecodeTime","tfhd","currentDts","defaultSampleDuration","defaultSampleSize","allSamples","forEach","trun","trackRun","parseTrun","duration","undefined","compositionTimeOffset","concat","parseCaptionNals","segment","videoTrackId","trafs","findBox","mdats","captionNals","mdatTrafPairs","mdat","index","matchingTraf","traf","pair","headerInfo","parseTfhd","tfdt","parseTfdt","seiNals","parseEmbeddedCaptions","timescale","CaptionParser","isInitialized","captionStream","segmentCache","parsedCaptions","parsingPartial","init","options","isPartial","on","event","startTime","startPts","endTime","endPts","captions","captionStreams","stream","isNewInit","videoTrackIds","timescales","Object","keys","parse","parsedData","cachedSegment","shift","pushNals","flushStream","nals","nal","flush","partialFlush","clearParsedCaptions","resetCaptionStream","reset","clearAllCaptions","module","exports"],"mappings":"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","sourcesContent":["/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Reads in-band CEA-708 captions out of FMP4 segments.\n * @see https://en.wikipedia.org/wiki/CEA-708\n */\n'use strict';\n\nvar discardEmulationPreventionBytes = require('../tools/caption-packet-parser').discardEmulationPreventionBytes;\nvar CaptionStream = require('../m2ts/caption-stream').CaptionStream;\nvar probe = require('./probe');\nvar inspect = require('../tools/mp4-inspector');\n\n/**\n  * Maps an offset in the mdat to a sample based on the the size of the samples.\n  * Assumes that `parseSamples` has been called first.\n  *\n  * @param {Number} offset - The offset into the mdat\n  * @param {Object[]} samples - An array of samples, parsed using `parseSamples`\n  * @return {?Object} The matching sample, or null if no match was found.\n  *\n  * @see ISO-BMFF-12/2015, Section 8.8.8\n **/\nvar mapToSample = function(offset, samples) {\n  var approximateOffset = offset;\n\n  for (var i = 0; i < samples.length; i++) {\n    var sample = samples[i];\n\n    if (approximateOffset < sample.size) {\n      return sample;\n    }\n\n    approximateOffset -= sample.size;\n  }\n\n  return null;\n};\n\n/**\n  * Finds SEI nal units contained in a Media Data Box.\n  * Assumes that `parseSamples` has been called first.\n  *\n  * @param {Uint8Array} avcStream - The bytes of the mdat\n  * @param {Object[]} samples - The samples parsed out by `parseSamples`\n  * @param {Number} trackId - The trackId of this video track\n  * @return {Object[]} seiNals - the parsed SEI NALUs found.\n  *   The contents of the seiNal should match what is expected by\n  *   CaptionStream.push (nalUnitType, size, data, escapedRBSP, pts, dts)\n  *\n  * @see ISO-BMFF-12/2015, Section 8.1.1\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\n **/\nvar findSeiNals = function(avcStream, samples, trackId) {\n  var\n    avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n    result = [],\n    seiNal,\n    i,\n    length,\n    lastMatchedSample;\n\n  for (i = 0; i + 4 < avcStream.length; i += length) {\n    length = avcView.getUint32(i);\n    i += 4;\n\n    // Bail if this doesn't appear to be an H264 stream\n    if (length <= 0) {\n      continue;\n    }\n\n    switch (avcStream[i] & 0x1F) {\n    case 0x06:\n      var data = avcStream.subarray(i + 1, i + 1 + length);\n      var matchingSample = mapToSample(i, samples);\n\n      seiNal = {\n        nalUnitType: 'sei_rbsp',\n        size: length,\n        data: data,\n        escapedRBSP: discardEmulationPreventionBytes(data),\n        trackId: trackId\n      };\n\n      if (matchingSample) {\n        seiNal.pts = matchingSample.pts;\n        seiNal.dts = matchingSample.dts;\n        lastMatchedSample = matchingSample;\n      } else {\n        // If a matching sample cannot be found, use the last\n        // sample's values as they should be as close as possible\n        seiNal.pts = lastMatchedSample.pts;\n        seiNal.dts = lastMatchedSample.dts;\n      }\n\n      result.push(seiNal);\n      break;\n    default:\n      break;\n    }\n  }\n\n  return result;\n};\n\n/**\n  * Parses sample information out of Track Run Boxes and calculates\n  * the absolute presentation and decode timestamps of each sample.\n  *\n  * @param {Array<Uint8Array>} truns - The Trun Run boxes to be parsed\n  * @param {Number} baseMediaDecodeTime - base media decode time from tfdt\n      @see ISO-BMFF-12/2015, Section 8.8.12\n  * @param {Object} tfhd - The parsed Track Fragment Header\n  *   @see inspect.parseTfhd\n  * @return {Object[]} the parsed samples\n  *\n  * @see ISO-BMFF-12/2015, Section 8.8.8\n **/\nvar parseSamples = function(truns, baseMediaDecodeTime, tfhd) {\n  var currentDts = baseMediaDecodeTime;\n  var defaultSampleDuration = tfhd.defaultSampleDuration || 0;\n  var defaultSampleSize = tfhd.defaultSampleSize || 0;\n  var trackId = tfhd.trackId;\n  var allSamples = [];\n\n  truns.forEach(function(trun) {\n    // Note: We currently do not parse the sample table as well\n    // as the trun. It's possible some sources will require this.\n    // moov > trak > mdia > minf > stbl\n    var trackRun = inspect.parseTrun(trun);\n    var samples = trackRun.samples;\n\n    samples.forEach(function(sample) {\n      if (sample.duration === undefined) {\n        sample.duration = defaultSampleDuration;\n      }\n      if (sample.size === undefined) {\n        sample.size = defaultSampleSize;\n      }\n      sample.trackId = trackId;\n      sample.dts = currentDts;\n      if (sample.compositionTimeOffset === undefined) {\n        sample.compositionTimeOffset = 0;\n      }\n      sample.pts = currentDts + sample.compositionTimeOffset;\n\n      currentDts += sample.duration;\n    });\n\n    allSamples = allSamples.concat(samples);\n  });\n\n  return allSamples;\n};\n\n/**\n  * Parses out caption nals from an FMP4 segment's video tracks.\n  *\n  * @param {Uint8Array} segment - The bytes of a single segment\n  * @param {Number} videoTrackId - The trackId of a video track in the segment\n  * @return {Object.<Number, Object[]>} A mapping of video trackId to\n  *   a list of seiNals found in that track\n **/\nvar parseCaptionNals = function(segment, videoTrackId) {\n  // To get the samples\n  var trafs = probe.findBox(segment, ['moof', 'traf']);\n  // To get SEI NAL units\n  var mdats = probe.findBox(segment, ['mdat']);\n  var captionNals = {};\n  var mdatTrafPairs = [];\n\n  // Pair up each traf with a mdat as moofs and mdats are in pairs\n  mdats.forEach(function(mdat, index) {\n    var matchingTraf = trafs[index];\n    mdatTrafPairs.push({\n      mdat: mdat,\n      traf: matchingTraf\n    });\n  });\n\n  mdatTrafPairs.forEach(function(pair) {\n    var mdat = pair.mdat;\n    var traf = pair.traf;\n    var tfhd = probe.findBox(traf, ['tfhd']);\n    // Exactly 1 tfhd per traf\n    var headerInfo = inspect.parseTfhd(tfhd[0]);\n    var trackId = headerInfo.trackId;\n    var tfdt = probe.findBox(traf, ['tfdt']);\n    // Either 0 or 1 tfdt per traf\n    var baseMediaDecodeTime = (tfdt.length > 0) ? inspect.parseTfdt(tfdt[0]).baseMediaDecodeTime : 0;\n    var truns = probe.findBox(traf, ['trun']);\n    var samples;\n    var seiNals;\n\n    // Only parse video data for the chosen video track\n    if (videoTrackId === trackId && truns.length > 0) {\n      samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);\n\n      seiNals = findSeiNals(mdat, samples, trackId);\n\n      if (!captionNals[trackId]) {\n        captionNals[trackId] = [];\n      }\n\n      captionNals[trackId] = captionNals[trackId].concat(seiNals);\n    }\n  });\n\n  return captionNals;\n};\n\n/**\n  * Parses out inband captions from an MP4 container and returns\n  * caption objects that can be used by WebVTT and the TextTrack API.\n  * @see https://developer.mozilla.org/en-US/docs/Web/API/VTTCue\n  * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack\n  * Assumes that `probe.getVideoTrackIds` and `probe.timescale` have been called first\n  *\n  * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n  * @param {Number} trackId - The id of the video track to parse\n  * @param {Number} timescale - The timescale for the video track from the init segment\n  *\n  * @return {?Object[]} parsedCaptions - A list of captions or null if no video tracks\n  * @return {Number} parsedCaptions[].startTime - The time to show the caption in seconds\n  * @return {Number} parsedCaptions[].endTime - The time to stop showing the caption in seconds\n  * @return {String} parsedCaptions[].text - The visible content of the caption\n **/\nvar parseEmbeddedCaptions = function(segment, trackId, timescale) {\n  var seiNals;\n\n  // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n  if (trackId === null) {\n    return null;\n  }\n\n  seiNals = parseCaptionNals(segment, trackId);\n\n  return {\n    seiNals: seiNals[trackId],\n    timescale: timescale\n  };\n};\n\n/**\n  * Converts SEI NALUs into captions that can be used by video.js\n **/\nvar CaptionParser = function() {\n  var isInitialized = false;\n  var captionStream;\n\n  // Stores segments seen before trackId and timescale are set\n  var segmentCache;\n  // Stores video track ID of the track being parsed\n  var trackId;\n  // Stores the timescale of the track being parsed\n  var timescale;\n  // Stores captions parsed so far\n  var parsedCaptions;\n  // Stores whether we are receiving partial data or not\n  var parsingPartial;\n\n  /**\n    * A method to indicate whether a CaptionParser has been initalized\n    * @returns {Boolean}\n   **/\n  this.isInitialized = function() {\n    return isInitialized;\n  };\n\n  /**\n    * Initializes the underlying CaptionStream, SEI NAL parsing\n    * and management, and caption collection\n   **/\n  this.init = function(options) {\n    captionStream = new CaptionStream();\n    isInitialized = true;\n    parsingPartial = options ? options.isPartial : false;\n\n    // Collect dispatched captions\n    captionStream.on('data', function(event) {\n      // Convert to seconds in the source's timescale\n      event.startTime = event.startPts / timescale;\n      event.endTime = event.endPts / timescale;\n\n      parsedCaptions.captions.push(event);\n      parsedCaptions.captionStreams[event.stream] = true;\n    });\n  };\n\n  /**\n    * Determines if a new video track will be selected\n    * or if the timescale changed\n    * @return {Boolean}\n   **/\n  this.isNewInit = function(videoTrackIds, timescales) {\n    if ((videoTrackIds && videoTrackIds.length === 0) ||\n        (timescales && typeof timescales === 'object' &&\n          Object.keys(timescales).length === 0)) {\n      return false;\n    }\n\n    return trackId !== videoTrackIds[0] ||\n      timescale !== timescales[trackId];\n  };\n\n  /**\n    * Parses out SEI captions and interacts with underlying\n    * CaptionStream to return dispatched captions\n    *\n    * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n    * @param {Number[]} videoTrackIds - A list of video tracks found in the init segment\n    * @param {Object.<Number, Number>} timescales - The timescales found in the init segment\n    * @see parseEmbeddedCaptions\n    * @see m2ts/caption-stream.js\n   **/\n  this.parse = function(segment, videoTrackIds, timescales) {\n    var parsedData;\n\n    if (!this.isInitialized()) {\n      return null;\n\n    // This is not likely to be a video segment\n    } else if (!videoTrackIds || !timescales) {\n      return null;\n\n    } else if (this.isNewInit(videoTrackIds, timescales)) {\n      // Use the first video track only as there is no\n      // mechanism to switch to other video tracks\n      trackId = videoTrackIds[0];\n      timescale = timescales[trackId];\n\n    // If an init segment has not been seen yet, hold onto segment\n    // data until we have one.\n    // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n    } else if (trackId === null || !timescale) {\n      segmentCache.push(segment);\n      return null;\n    }\n\n    // Now that a timescale and trackId is set, parse cached segments\n    while (segmentCache.length > 0) {\n      var cachedSegment = segmentCache.shift();\n\n      this.parse(cachedSegment, videoTrackIds, timescales);\n    }\n\n    parsedData = parseEmbeddedCaptions(segment, trackId, timescale);\n\n    if (parsedData === null || !parsedData.seiNals) {\n      return null;\n    }\n\n    this.pushNals(parsedData.seiNals);\n    // Force the parsed captions to be dispatched\n    this.flushStream();\n\n    return parsedCaptions;\n  };\n\n  /**\n    * Pushes SEI NALUs onto CaptionStream\n    * @param {Object[]} nals - A list of SEI nals parsed using `parseCaptionNals`\n    * Assumes that `parseCaptionNals` has been called first\n    * @see m2ts/caption-stream.js\n    **/\n  this.pushNals = function(nals) {\n    if (!this.isInitialized() || !nals || nals.length === 0) {\n      return null;\n    }\n\n    nals.forEach(function(nal) {\n      captionStream.push(nal);\n    });\n  };\n\n  /**\n    * Flushes underlying CaptionStream to dispatch processed, displayable captions\n    * @see m2ts/caption-stream.js\n   **/\n  this.flushStream = function() {\n    if (!this.isInitialized()) {\n      return null;\n    }\n\n    if (!parsingPartial) {\n      captionStream.flush();\n    } else {\n      captionStream.partialFlush();\n    }\n  };\n\n  /**\n    * Reset caption buckets for new data\n   **/\n  this.clearParsedCaptions = function() {\n    parsedCaptions.captions = [];\n    parsedCaptions.captionStreams = {};\n  };\n\n  /**\n    * Resets underlying CaptionStream\n    * @see m2ts/caption-stream.js\n   **/\n  this.resetCaptionStream = function() {\n    if (!this.isInitialized()) {\n      return null;\n    }\n\n    captionStream.reset();\n  };\n\n  /**\n    * Convenience method to clear all captions flushed from the\n    * CaptionStream and still being parsed\n    * @see m2ts/caption-stream.js\n   **/\n  this.clearAllCaptions = function() {\n    this.clearParsedCaptions();\n    this.resetCaptionStream();\n  };\n\n  /**\n    * Reset caption parser\n   **/\n  this.reset = function() {\n    segmentCache = [];\n    trackId = null;\n    timescale = null;\n\n    if (!parsedCaptions) {\n      parsedCaptions = {\n        captions: [],\n        // CC1, CC2, CC3, CC4\n        captionStreams: {}\n      };\n    } else {\n      this.clearParsedCaptions();\n    }\n\n    this.resetCaptionStream();\n  };\n\n  this.reset();\n};\n\nmodule.exports = CaptionParser;\n"]},"metadata":{},"sourceType":"script"}